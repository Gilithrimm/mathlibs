package com.safenar.math;

import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.stream.LongStream;

/**
 * A Sequence is a series of numbers generated by a specific rule
 * (aka a {@link com.safenar.math.Generator}) from numbers between
 * {@linkplain Sequence#min} and {@linkplain Sequence#max}.
 *
 * @author Gilithrimm
 * @since 1.0.0
 * */
public class Sequence implements Iterable<Integer> {
	/**Minimum and maximum indexes.*/
	protected final int min, max;//for x
	/**{@link Generator} by which this sequence is created.*/
	protected final Generator generator;//TODO adding two or more Sequences/Generators together
	private final Iter iter;//one inst per seq
	/**
	 * Default constructor.
	 * @implSpec generator should be always changed to {@link Generators#NULL}
	 * if null was passed
	 * @param min minimum index
	 * @param max maximum index
	 * @param generator {@link Generator generator} for this sequence
	 */
	public Sequence(int min, int max, Generator generator) {
		this.min = min;
		this.max = max;
		this.generator = generator == null
				? Generators.NULL
				: generator;
		iter = new Iter(this);
	}
	
	public int getMin() {
		return min;
	}
	public int getMax() {
		return max;
	}
	
	/**
	 * Calculates the length of this sequence, or how many elements can be in this sequence.
	 * @return length of this Sequence
	 * @apiNote if this method returns 0, then this sequence is empty
	 * */
	public int getLength() {
		return max - min + 1;
	}
	
	/**
	 * Turns this Sequence into array of numbers.
	 * @return array representing this Sequence
	 * */
	public long[] toArray() {
		return LongStream.range(0, getLength())
				.map(i -> value((int) (min + i)))
				.toArray();
	}
	
	/**
	 * Generates an element for given index
	 * @throws IndexOutOfBoundsException if there is no value in this sequence at given index
	 * @return value at the given index
	 * @param index position of the value
	 * */
	public int value(int index) {
		if (index>max||index<min)
			throw new IndexOutOfBoundsException("There's no value at this index (%d) in this sequence: %s"
					.formatted(index,toString()));
		return generator.generate(index);
	}
	
	/**
	 * Returns the index of the first occurrence of the specified element in this sequence.
	 * @throws IndexOutOfBoundsException if the value is not in the sequence
	 * @return the position of the value in this sequence
	 * @param value the value whose index we are looking for
	 * @implNote It will return only <b>first</b> matching index
	 * */
	public int indexOf(int value) {
		for (int i = min; i < max; i++) {
			if (value == value(i)) {
				return i;
			}
		}
		throw new IndexOutOfBoundsException(value + "is out of bound for this sequence: " + this);
	}
	
	/**
	 * Returns string representation as {@linkplain #toArray() an array}.
	 * @return string representation of this sequence as an array.
	 */
	@Override
	public String toString() {
		return Arrays.toString(toArray());
	}
	
	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (!(o instanceof Sequence sequence)) return false;
		return min == sequence.min
				&& max == sequence.max
				&& generator.equals(sequence.generator);
	}
	
	@Override
	public int hashCode() {
		return Objects.hash(min, max, generator.hash());
	}
	
	@Override
	public Iterator<Integer> iterator() {
		return iter;
	}
	
	private static class Iter implements Iterator<Integer> {
		int current=0,min,max;
		private final Generator gen;//breakdown to avoid recursion
		
		public Iter(Sequence seq) {
			gen = seq.generator;
			max = seq.max;
			min=seq.min;
		}
		
		@Override
		public boolean hasNext() {
			return current < max+1-min;
		}
		
		@Override
		public Integer next() {
			if (!hasNext()) throw new NoSuchElementException();
			return gen.generate(++current);
		}
	}
}